name: Claude Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened]
  issue_comment:
    types: [created]

permissions:
  contents: read
  pull-requests: write
  issues: write
  actions: read
  id-token: write

jobs:
  claude-review:
    if: |
      (github.event_name == 'pull_request') ||
      (github.event_name == 'issue_comment' &&
       github.event.issue.pull_request &&
       contains(github.event.comment.body, '@claude'))
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Wait for CI workflows to complete
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const head_sha = context.payload.pull_request.head.sha;

            // Map workflow file names to display names
            const requiredWorkflows = [
              { file: 'ci.yml', name: 'CI' },
              { file: 'lint.yml', name: 'Lint' },
              { file: 'govulncheck.yml', name: 'Vulnerability Check' }
            ];

            const maxAttempts = 60;  // 30 minutes max wait (60 * 30s)
            const pollInterval = 30000;  // 30 seconds

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
              console.log(`Attempt ${attempt}/${maxAttempts}: Checking workflow status...`);

              // Get all workflow runs for this commit
              const { data: workflowRuns } = await github.rest.actions.listWorkflowRunsForRepo({
                owner,
                repo,
                head_sha,
                per_page: 100,
              });

              // Find the status of required workflows
              const workflowStatus = {};
              for (const workflow of requiredWorkflows) {
                // Find runs matching this workflow file
                const matchingRuns = workflowRuns.workflow_runs.filter(run =>
                  run.path === `.github/workflows/${workflow.file}`
                );

                if (matchingRuns.length === 0) {
                  workflowStatus[workflow.name] = 'pending';
                } else {
                  // Get the most recent run for this workflow
                  const latestRun = matchingRuns.sort((a, b) =>
                    new Date(b.created_at) - new Date(a.created_at)
                  )[0];

                  if (latestRun.status !== 'completed') {
                    workflowStatus[workflow.name] = 'in_progress';
                  } else if (latestRun.conclusion === 'success') {
                    workflowStatus[workflow.name] = 'success';
                  } else {
                    workflowStatus[workflow.name] = 'failure';
                  }
                }
              }

              console.log('Workflow status:', JSON.stringify(workflowStatus, null, 2));

              // Check if any workflow failed
              const failed = Object.entries(workflowStatus).filter(([_, status]) => status === 'failure');
              if (failed.length > 0) {
                core.setFailed(`CI workflows failed: ${failed.map(([name]) => name).join(', ')}. Skipping Claude review to save tokens.`);
                return;
              }

              // Check if all workflows succeeded
              const allSucceeded = Object.values(workflowStatus).every(status => status === 'success');
              if (allSucceeded) {
                console.log('All CI workflows passed! Proceeding with Claude review.');
                return;
              }

              // Still waiting
              console.log(`Waiting ${pollInterval/1000}s before next check...`);
              await new Promise(resolve => setTimeout(resolve, pollInterval));
            }

            core.setFailed('Timeout waiting for CI workflows to complete');

      - name: Run Claude Code Review
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          trigger_phrase: "@claude"
          claude_args: |
            --allowedTools "mcp__github__get_pull_request,mcp__github__list_pull_requests,mcp__github__create_pending_pull_request_review,mcp__github__add_pull_request_review_comment_to_pending_review,mcp__github__submit_pending_pull_request_review,mcp__github__get_pull_request_diff,mcp__github_inline_comment__create_inline_comment,Bash(gh pr:*),Bash(gh api:*)"
          prompt: |
            You are a senior code reviewer for bishop, a Go-based intelligent shell with AI agent capabilities.

            ## IMPORTANT: Review Comment Format

            You MUST post your review as GitHub review comments directly on the pull request:

            1. **Use inline comments** for file-specific feedback - place comments directly on the relevant lines of code
            2. **Use GitHub's suggestion feature** for concrete code improvements by wrapping suggested code in suggestion blocks:
               ```suggestion
               // your improved code here
               ```
            3. **Submit a PR review** with an overall summary using the pending review workflow:
               - First create a pending review
               - Add inline comments to the pending review for specific code locations
               - Submit the review with an overall assessment (APPROVE, REQUEST_CHANGES, or COMMENT)

            DO NOT output the review to stdout. All feedback must be posted as GitHub review comments.

            ## Project Context
            Bishop is a CLI tool that provides:
            - An AI agent that can execute commands on behalf of users
            - Chat macros and permission management system
            - Magic fix functionality for failed commands
            - Tab completion and interactive features

            ## Review Focus Areas

            **Security** (Critical for a shell tool):
            - Command injection vulnerabilities
            - Permission bypass risks in the agent system
            - Insecure handling of user input or shell commands
            - Authentication and authorization issues

            **Go Best Practices**:
            - Proper error handling (no ignored errors)
            - Resource management (defer for cleanup)
            - Goroutine safety and race conditions
            - Effective use of interfaces and types

            **Performance**:
            - Efficient algorithms and data structures
            - Memory management concerns
            - Unnecessary allocations or computations

            **Code Quality**:
            - Clear, maintainable code
            - Consistent style and naming conventions
            - Appropriate test coverage
            - Documentation for public APIs

            ## Review Process
            1. Get the PR diff using the available tools
            2. Create a pending pull request review
            3. For each issue found:
               - Add an inline comment to the pending review at the specific file and line
               - For code improvements, use GitHub suggestion blocks so reviewers can apply fixes with one click
            4. Submit the review with:
               - REQUEST_CHANGES if there are security issues or bugs
               - COMMENT for style suggestions or minor improvements
               - APPROVE if the code is ready to merge
            5. Include a summary of the review in the submission

            Be constructive and explain the reasoning behind suggestions. Prioritize critical security and correctness issues over style preferences.
